syntax = "proto3";

package cosmos.accounts.defaults.multisig.v1;

import "google/protobuf/any.proto";
import "cosmos/msg/v1/msg.proto";
import "cosmos_proto/cosmos.proto";

option go_package = "cosmossdk.io/x/accounts/defaults/multisig/v1";

// MsgInit is used to initialize a multisig account.
message MsgInit {
  // pub_key defines the pubkey bytes of the multisig members. If the signing algo is "default"
  // then these are addresses and not pubkeys.
  repeated bytes pub_keys = 1;

  repeated uint64 weights = 2;

  //map<bytes, uint64> members = 1; // OR???

  Config Config = 3;
}

// when aggregating on-chain I can only use the address
// off-chain would send a tx directly, won't create a proposal.

message Config {
  // algo defines the algorithm used for the multisig. default, secp256k1, bls12_381, etc.
  // can't be changed after creation.
  // If it's "default" then no signature verification is carried out on the multisig, we expect
  // the signer of the MsgVote to be the member.
  string algo = 1;

  int64 threshold = 2;

  int64 quorum = 3;

  // voting_period is the duration in seconds for the voting period.
  int64 voting_period = 4;

  // revote defines if members can change their vote.
  bool revote = 5;

  // early_execution defines if the multisig can be executed before the voting period ends.
  bool early_execution = 6;
}

message Proposal {
  string   title                        = 1;
  string   summary                      = 2;
  repeated google.protobuf.Any messages = 3;
}

// MsgInitResponse is the response returned after base account initialization.
// This is empty.
message MsgInitResponse {}

message MsgCreateProposal {
  // I don't need the signer
  // option (cosmos.msg.v1.signer) = "signer";
  // string signer = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  Proposal proposal = 2;

  // TODO: Could i use this for the default sign mode? So I get signatures produced with cosmos sdk keys and execute asap.
  // append optional signatures that will be converted into positive votes
  repeated bytes signatures = 3;

  // if true, the proposal will execute as soon as the quorum is reached.
  bool execute = 4;
}

// MsgUpdateConfigRequest is used to change the config or members.
message MsgUpdateConfigRequest {
  // only the members that are changing are required, if their weight is 0, they are removed.
  repeated bytes update_pub_keys = 1;

  repeated uint64 update_weights = 2;

  // not all fields from Config can be changed
  Config Config = 3;
}

// MsgSwapPubKeyResponse is the response for the MsgSwapPubKey message.
// This is empty.
message MsgUpdateConfigResponse {}

// QuerySequence is the request for the account sequence.
message QuerySequence {}

// QuerySequenceResponse returns the sequence of the account.
message QuerySequenceResponse {
  // sequence is the current sequence of the account.
  uint64 sequence = 1;
}

message QueryConfig {}

// QuerySequenceResponse returns the sequence of the account.
message QueryConfigResponse {
  // pub_key defines the pubkey bytes of the multisig members.
  repeated bytes pub_keys = 1;

  repeated uint64 weights = 2;

  Config Config = 3;
}

message QueryProposal {
  uint64 proposal_id = 1;
}

message QueryProposalResponse {
  Proposal proposal = 1;
}

message MsgVote {
  // option (cosmos.msg.v1.signer) = "signer";

  // string signer      = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
  uint64 proposal_id = 2;
  bool   vote        = 3;

  // signature is only required when the algo is not "default".
  optional bytes signature = 4;
}

message MsgVoteResponse {}

message MsgExecuteProposal {
  option (cosmos.msg.v1.signer) = "signer";

  string signer      = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
  uint64 proposal_id = 2;
}

message MsgExecuteProposalResponse {}